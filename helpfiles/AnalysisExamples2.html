
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>AnalysisExamples2</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-03-02"><meta name="DC.source" content="AnalysisExamples2.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Analysis Examples 2</a></li><li><a href="#8">Toolbox vs. Standard GLM comparison</a></li><li><a href="#9">Compute the history effect</a></li></ul></div><h2>Analysis Examples 2<a name="1"></a></h2><p>Compare with traditional Neural Spike Train Analysis <a href="matlab:web('AnalysisExamples.html','-helpbrowser')">here</a></p><pre class="codeinput"><span class="comment">% load the rat trajectory and spiking data;</span>
close <span class="string">all</span>;
warning <span class="string">off</span>;
load(<span class="string">'glm_data.mat'</span>);

nst = nspikeTrain(spiketimes);
baseline = Covariate(T,ones(length(xN),1),<span class="string">'Baseline'</span>,<span class="string">'time'</span>,<span class="string">'s'</span>,<span class="string">''</span>,{<span class="string">'mu'</span>});
position = Covariate(T,[xN yN],<span class="string">'Position'</span>, <span class="string">'time'</span>,<span class="string">'s'</span>,<span class="string">'m'</span>,{<span class="string">'x'</span>,<span class="string">'y'</span>});
velocity = Covariate(T,[vxN,vyN],<span class="string">'Velocity'</span>,<span class="string">'time'</span>,<span class="string">'s'</span>,<span class="string">'m/s'</span>,{<span class="string">'v_x'</span>,<span class="string">'v_y'</span>});
radial   = Covariate(T,[xN yN xN.^2 yN.^2 xN.*yN],<span class="string">'Radial'</span>,<span class="string">'time'</span>,<span class="string">'s'</span>,<span class="string">'m'</span>,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'x^2'</span>,<span class="string">'y^2'</span>,<span class="string">'x*y'</span>});
<span class="comment">% could just define velocity = postion.derivative;</span>

<span class="comment">%possibly add view as vector for covariates of dimension 3 or less</span>
</pre><p>In the original analysis, we already had vectors of the covariates sampled at the spiketimes. This step would require interpolating the covariates and then sampling them at each of the spikeTimes. In our case this is quite simple.</p><pre class="codeinput">[values_at_spiketimes] =position.getValueAt(spiketimes);
</pre><p>We could also upsample our data to get better estimates of the covariates at these points</p><pre class="codeinput">[values_at_spiketimes] =position.resample(1/min(diff(spiketimes))).getValueAt(spiketimes);
</pre><p>visualize the raw data</p><pre class="codeinput">figure;
plot(position.getSubSignal(<span class="string">'x'</span>).dataToMatrix,position.getSubSignal(<span class="string">'y'</span>).dataToMatrix,<span class="keyword">...</span>
     values_at_spiketimes(:,1),values_at_spiketimes(:,2),<span class="string">'r.'</span>);
axis <span class="string">tight</span> <span class="string">square</span>;
xlabel(<span class="string">'x position (m)'</span>); ylabel(<span class="string">'y position (m)'</span>);
</pre><img vspace="5" hspace="5" src="AnalysisExamples2_01.png" alt=""> <p>Create a trial object and define the fits that we want to run</p><pre class="codeinput">spikeColl = nstColl({nst});
covarColl = CovColl({baseline,radial});
trial     = Trial(spikeColl,covarColl);
clear <span class="string">tc</span>;
sampleRate=30;
<span class="comment">% tcObj=TrialConfig(covMask,sampleRate, history,minTime,maxTime)</span>
tc{1} = TrialConfig({{<span class="string">'Baseline'</span>,<span class="string">'mu'</span>},{<span class="string">'Radial'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>}},sampleRate,[]); tc{1}.setName(<span class="string">'Linear'</span>);
tc{2} = TrialConfig({{<span class="string">'Baseline'</span>,<span class="string">'mu'</span>},{<span class="string">'Radial'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'x^2'</span>,<span class="string">'y^2'</span>,<span class="string">'x*y'</span>}},sampleRate,[]); tc{2}.setName(<span class="string">'Quadratic'</span>);
tc{3} = TrialConfig({{<span class="string">'Baseline'</span>,<span class="string">'mu'</span>},{<span class="string">'Radial'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'x^2'</span>,<span class="string">'y^2'</span>,<span class="string">'x*y'</span>}},sampleRate,[0 1]./sampleRate); tc{3}.setName(<span class="string">'Quadratic+Hist'</span>);
</pre><p>Create our collection of configurations and run the analysis;</p><pre class="codeinput">tcc = ConfigColl(tc); makePlot=1; neuronNum=1;
fitResults =Analysis.RunAnalysisForAllNeurons(trial,tcc,0);
fitResults.plotResults;
</pre><pre class="codeoutput">Analyzing Configuration #1: Neuron #1
Analyzing Configuration #2: Neuron #1
Analyzing Configuration #3: Neuron #1
</pre><img vspace="5" hspace="5" src="AnalysisExamples2_02.png" alt=""> <p>Visualize the firing rates as a function of the spatial covariates</p><pre class="codeinput">figure;
[x_new,y_new]=meshgrid(-1:.1:1); <span class="comment">%define new x and y</span>
y_new = flipud(y_new);
x_new = fliplr(x_new);

<span class="comment">%For each covariate new to place the new data in a cell array</span>
newData{1} =ones(size(x_new));
newData{2} =x_new; newData{3} =y_new;
newData{4} =x_new.^2; newData{5} =y_new.^2;
newData{6} =x_new.*y_new;
color = Analysis.colors;

<span class="comment">% Evaluate our fits using the new parameters</span>
<span class="keyword">for</span> i=1:fitResults.numResults

    lambda = fitResults.evalLambda(i,newData);
    h_mesh = mesh(x_new,y_new,lambda,<span class="string">'AlphaData'</span>,0);
    get(h_mesh,<span class="string">'AlphaData'</span>);
    set(h_mesh,<span class="string">'FaceAlpha'</span>,0.2,<span class="string">'EdgeAlpha'</span>,0.8,<span class="string">'EdgeColor'</span>,color{i});
    <span class="comment">%figure;</span>
    hold <span class="string">on</span>;
<span class="keyword">end</span>
legend(fitResults.lambda.dataLabels);
plot(position.getSubSignal(<span class="string">'x'</span>).dataToMatrix,position.getSubSignal(<span class="string">'y'</span>).dataToMatrix,<span class="keyword">...</span>
     values_at_spiketimes(:,1),values_at_spiketimes(:,2),<span class="string">'r.'</span>);
axis <span class="string">tight</span> <span class="string">square</span>;
xlabel(<span class="string">'x position (m)'</span>); ylabel(<span class="string">'y position (m)'</span>);
</pre><img vspace="5" hspace="5" src="AnalysisExamples2_03.png" alt=""> <h2>Toolbox vs. Standard GLM comparison<a name="8"></a></h2><p>Compare the results using our approach with the standard approach used in the first example previous standard regression</p><pre class="codeinput">[b,dev,stats] = glmfit([xN yN xN.^2 yN.^2 xN.*yN],spikes_binned,<span class="string">'poisson'</span>);
b-fitResults.b{2} <span class="comment">% should be close to zero</span>
</pre><pre class="codeoutput">
ans =

   -0.0011
    0.0050
    0.0034
    0.0069
    0.0077
    0.0165

</pre><h2>Compute the history effect<a name="9"></a></h2><pre class="codeinput">sampleRate=30;  makePlot=1; neuronNum = 1;
covLabels = {{<span class="string">'Baseline'</span>,<span class="string">'mu'</span>}};
Algorithm = <span class="string">'GLM'</span>;
batchMode=0;
windowTimes =(0:2:10)./sampleRate;
[fitResults,tcc] = Analysis.computeHistLag(trial,neuronNum,windowTimes,covLabels,Algorithm,batchMode,sampleRate,makePlot);
</pre><pre class="codeoutput">Analyzing Configuration #1: Neuron #1
Analyzing Configuration #2: Neuron #1
Analyzing Configuration #3: Neuron #1
Analyzing Configuration #4: Neuron #1
Analyzing Configuration #5: Neuron #1
Analyzing Configuration #6: Neuron #1
</pre><img vspace="5" hspace="5" src="AnalysisExamples2_04.png" alt=""> <p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
%% Analysis Examples 2
% Compare with traditional Neural Spike Train Analysis
% <matlab:web('AnalysisExamples.html','-helpbrowser') here>

% load the rat trajectory and spiking data;
close all;
warning off;
load('glm_data.mat');

nst = nspikeTrain(spiketimes);
baseline = Covariate(T,ones(length(xN),1),'Baseline','time','s','',{'mu'});
position = Covariate(T,[xN yN],'Position', 'time','s','m',{'x','y'});
velocity = Covariate(T,[vxN,vyN],'Velocity','time','s','m/s',{'v_x','v_y'});
radial   = Covariate(T,[xN yN xN.^2 yN.^2 xN.*yN],'Radial','time','s','m',{'x','y','x^2','y^2','x*y'});
% could just define velocity = postion.derivative;

%possibly add view as vector for covariates of dimension 3 or less
%%
% In the original analysis, we already had vectors of the covariates
% sampled at the spiketimes. This step would require interpolating the
% covariates and then sampling them at each of the spikeTimes. In our case
% this is quite simple.

[values_at_spiketimes] =position.getValueAt(spiketimes); 

%%
% We could also upsample our data to get better estimates of the covariates
% at these points

[values_at_spiketimes] =position.resample(1/min(diff(spiketimes))).getValueAt(spiketimes); 

%%
% visualize the raw data
figure;
plot(position.getSubSignal('x').dataToMatrix,position.getSubSignal('y').dataToMatrix,...
     values_at_spiketimes(:,1),values_at_spiketimes(:,2),'r.');
axis tight square;
xlabel('x position (m)'); ylabel('y position (m)');

%%
% Create a trial object and define the fits that we want to run
spikeColl = nstColl({nst});
covarColl = CovColl({baseline,radial});
trial     = Trial(spikeColl,covarColl);
clear tc;
sampleRate=30;
% tcObj=TrialConfig(covMask,sampleRate, history,minTime,maxTime)
tc{1} = TrialConfig({{'Baseline','mu'},{'Radial','x','y'}},sampleRate,[]); tc{1}.setName('Linear');
tc{2} = TrialConfig({{'Baseline','mu'},{'Radial','x','y','x^2','y^2','x*y'}},sampleRate,[]); tc{2}.setName('Quadratic');
tc{3} = TrialConfig({{'Baseline','mu'},{'Radial','x','y','x^2','y^2','x*y'}},sampleRate,[0 1]./sampleRate); tc{3}.setName('Quadratic+Hist');

%% 
% Create our collection of configurations and run the analysis;
tcc = ConfigColl(tc); makePlot=1; neuronNum=1;
fitResults =Analysis.RunAnalysisForAllNeurons(trial,tcc,0);
fitResults.plotResults;

%%
% Visualize the firing rates as a function of the spatial covariates
figure;
[x_new,y_new]=meshgrid(-1:.1:1); %define new x and y
y_new = flipud(y_new);
x_new = fliplr(x_new);

%For each covariate new to place the new data in a cell array
newData{1} =ones(size(x_new));
newData{2} =x_new; newData{3} =y_new; 
newData{4} =x_new.^2; newData{5} =y_new.^2; 
newData{6} =x_new.*y_new; 
color = Analysis.colors;

% Evaluate our fits using the new parameters
for i=1:fitResults.numResults
   
    lambda = fitResults.evalLambda(i,newData);
    h_mesh = mesh(x_new,y_new,lambda,'AlphaData',0);
    get(h_mesh,'AlphaData');
    set(h_mesh,'FaceAlpha',0.2,'EdgeAlpha',0.8,'EdgeColor',color{i});
    %figure;
    hold on;
end
legend(fitResults.lambda.dataLabels);
plot(position.getSubSignal('x').dataToMatrix,position.getSubSignal('y').dataToMatrix,...
     values_at_spiketimes(:,1),values_at_spiketimes(:,2),'r.');
axis tight square;
xlabel('x position (m)'); ylabel('y position (m)');

%% Toolbox vs. Standard GLM comparison 
% Compare the results using our approach with the standard approach used in
% the first example previous standard regression 
[b,dev,stats] = glmfit([xN yN xN.^2 yN.^2 xN.*yN],spikes_binned,'poisson');
b-fitResults.b{2} % should be close to zero



%% Compute the history effect
sampleRate=30;  makePlot=1; neuronNum = 1;
covLabels = {{'Baseline','mu'}};
Algorithm = 'GLM';
batchMode=0;
windowTimes =(0:2:10)./sampleRate;
[fitResults,tcc] = Analysis.computeHistLag(trial,neuronNum,windowTimes,covLabels,Algorithm,batchMode,sampleRate,makePlot);

##### SOURCE END #####
--></body></html>